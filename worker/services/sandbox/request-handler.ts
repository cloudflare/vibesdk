/*
This code is borrowed from Cloudflare Sandbox-sdk's npm package
*/

import { createObjectLogger } from "../../logger";
import { getSandbox, type Sandbox } from "@cloudflare/sandbox";

const logger = createObjectLogger({
  component: 'sandbox-do',
  operation: 'proxy'
});

export interface SandboxEnv {
  Sandbox: DurableObjectNamespace<Sandbox>;
}

export interface RouteInfo {
  port: number;
  sandboxId: string;
  path: string;
  token: string;
}

export async function proxyToSandbox<E extends SandboxEnv>(
  request: Request,
  env: E
): Promise<Response | null> {
  try {
    const url = new URL(request.url);
    const routeInfo = extractSandboxRoute(url);

    if (!routeInfo) {
      return null; // Not a request to an exposed container port
    }

    const { sandboxId, port, path, token } = routeInfo;
    const sandbox = getSandbox(env.Sandbox, sandboxId);

    // Build proxy request with proper headers
    let proxyUrl: string;

    // Route based on the target port
    if (port !== 3000) {
      // Route directly to user's service on the specified port
      proxyUrl = `http://localhost:${port}${path}${url.search}`;
    } else {
      // Port 3000 is our control plane - route normally
      proxyUrl = `http://localhost:3000${path}${url.search}`;
    }

    const proxyRequest = new Request(proxyUrl, {
      method: request.method,
      headers: {
        ...Object.fromEntries(request.headers),
        'X-Original-URL': request.url,
        'X-Forwarded-Host': url.hostname,
        'X-Forwarded-Proto': url.protocol.replace(':', ''),
        'X-Sandbox-Name': sandboxId, // Pass the friendly name
      },
      body: request.body,
      // @ts-expect-error - duplex required for body streaming in modern runtimes
      duplex: 'half',
    });

    logger.info('Proxying request to sandbox', {
      sandboxId,
      port,
      path,
      token,
      proxyUrl,
    });

    return sandbox.containerFetch(proxyRequest, port);
  } catch (error) {
    logger.error('Proxy routing error', error instanceof Error ? error : new Error(String(error)));
    return new Response('Proxy routing error', { status: 500 });
  }
}

function extractSandboxRoute(url: URL): RouteInfo | null {
  // Parse subdomain pattern: port-sandboxId-token.domain (tokens mandatory)
  // Token is always exactly 16 chars (generated by generatePortToken)
  const subdomainMatch = url.hostname.match(/^(\d{4,5})-([^.-][^.]*?[^.-]|[^.-])-([a-z0-9_-]{16})\.(.+)$/);

  if (!subdomainMatch) {
    return null;
  }

  const portStr = subdomainMatch[1];
  const sandboxId = subdomainMatch[2];
  const token = subdomainMatch[3]; // Mandatory token

  const port = parseInt(portStr, 10);

  // DNS subdomain length limit is 63 characters
  if (sandboxId.length > 63) {
    return null;
  }

  return {
    port,
    sandboxId,
    path: url.pathname || "/",
    token,
  };
}

export function isLocalhostPattern(hostname: string): boolean {
  // Handle IPv6 addresses in brackets (with or without port)
  if (hostname.startsWith('[')) {
    if (hostname.includes(']:')) {
      // [::1]:port format
      const ipv6Part = hostname.substring(0, hostname.indexOf(']:') + 1);
      return ipv6Part === '[::1]';
    } else {
      // [::1] format without port
      return hostname === '[::1]';
    }
  }
  
  // Handle bare IPv6 without brackets
  if (hostname === '::1') {
    return true;
  }
  
  // For IPv4 and regular hostnames, split on colon to remove port
  const hostPart = hostname.split(":")[0];
  
  return (
    hostPart === "localhost" ||
    hostPart === "127.0.0.1" ||
    hostPart === "0.0.0.0"
  );
}
